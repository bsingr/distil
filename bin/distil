#!/usr/bin/env ruby

$script_dir= File.expand_path(File.join(File.dirname(__FILE__), "..", "lib"))
$vendor_dir= File.expand_path(File.join(File.dirname(__FILE__), "..", "vendor"))
$app_name= File.basename($0)

require "yaml"
require "#{$script_dir}/target"

arg_settings= {}
distil_file= "distil.yml"
args= []

ARGV.each { |v|
  if (!v[/^-/])
    args << v
    next
  end
  
  v= v.gsub(/^-+/, '')
  v.gsub!("-", "_")
  
  key,value= v.split("=")
  if (!value)
    value= true
  end
  
  if ("f"==key || "file"==key || "buildfile"==key)
    distil_file= value
    next
  end
  
  arg_settings[key.to_sym]= value
}

# Change working directory to the folder containing the build YML file.
distil_file= File.expand_path(distil_file)
Dir.chdir(File.dirname(distil_file))

if (!File.exists?(distil_file))
  puts "#{$app_name}: can't find project file: #{distil_file}"
  exit
end

Task.set_global_options({
    :formats=> ["concat", "gz", "min", "debug"],
    :output_folder=> Dir.getwd
  })

# Override default settings with options from the command line
Task.set_global_options(arg_settings.clone)

build_info= YAML.load_file(distil_file)
Task.set_global_options(build_info)

options= Task.options

# Handle external projects
options.external_projects.map! { |project|
  
  if (project.is_a?(String))
    project= {
      "folder"=>project,
      "build"=>"distil",
      "include"=>File.join(project, "build")
    }
  end

  if (project.key?("folder") && !File.directory?(project["folder"]))
    puts "#{distil_file}: external project folder missing: #{project["folder"]}"
    exit
  end
  
  if (!project.key?("include"))
    project["include"]= File.join(project["folder"], "build")
  end
  
  if (!File.directory?(project["include"]))
    build= project["build"] || "distil"
    wd= Dir.pwd
    Dir.chdir(project["folder"]||project["include"])
    # pass along mode flag to sub-projects
    if (arg_settings.key?("mode"))
      build= "#{build} -mode=#{arg_settings["mode"]}"
    end
    system(build)
    Dir.chdir(wd)
  end
  
  # Make certain to yield a value for the map! operation.
  project
}

build_info.each { |section, value|
  next if (options.targets && !options.targets.include?(section))
  next if ((!options.targets || !options.targets.include?(section)) &&
       value.is_a?(Hash) && value.has_key?("enabled") && !value["enabled"])

  puts
  puts "#{options.name}-#{section}:"
  puts
    
  target= Target.new(section, value)
  target.process_files
  target.finish
}
